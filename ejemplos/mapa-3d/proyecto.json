{"hash":"9ae39bde-457b-4fc6-ad18-95567837d653","fecha":"2025-03-30T13:03:05.815Z","version":"1","screenshot":"data:image/png;base64,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","textura":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAAoCAYAAAA2cfJIAAAAAXNSR0IArs4c6QAABIlJREFUeF7tnD9oFzEUxxNnpaOKdeggRQXHFsF2F1GopSBK6dCpIjgIVkEcdNAODoLUqYOIokgVdOgotIO0kwgqxaGDP1FBEHFxMpL03jW/NHnvcsm1+f3MLf3d711yyXuf982fu185o47WgKAuyfY4HhC9uxlvfQ+qzLcOTt5NAtC7Yr8O4Mj2jvVPEACCnRSK2A4GQGUMe9WxAVQJHOD/IAAYoQDdAEiog1Mv3ygAFCBV7KllqIIaFGMLEiC0/1T55AFIPYM6vX1dDUAegooVHDJHqAYAuVTwu8C2VJHfHZp/qSr6ODjoV2GNq32XSzVu4Syynfc2G0UDELPnua7kPJABSC4kW9sgbwDEr2+C9+zxLre13cp3q+qBMpAysLIQBNd1DhVnCKq6OO3rFAAQbN+mZgh8PZbe9bxu8LMSpBfMOi3KY3kdr3VRmQxAFwWzTldoALb5fYCJS3vRfk1euILah470oXZqHiMeMvx9iOP9eP1/elD7weVl1H52eQ61X+M78biP7cDbR1JTACB2re/S6Qf/fao8lXY+O8XY+Bemf9av1+vQy6qJqFE/2CUAMshz926rqvTPcI71oQoAcsvYVod86BMNgIf7lG/KozjvKABUgItDnL/PfAAoodDLF8AAAJvqn51iE2//OuNLZb8sWBUA850AeOoXAgAnsl+2LzoAM48Ymz634bOYCgAZXgbMpgAymyUcWnDbAlxkgakSrnMbAKACMQEAjwEIMQCQdVoh0NSgEQDkjQGCmAC0yb8lwD525RxDAWzlsSEgJgB64HUYQhSgBMCUf62jUQCQWW87JAQxAdAlWt1PH9PkuewopQDUEGIMEdgQIC+lINjOIcCpALEB0IMPMDShAKas6/fdNImLNAQsHrtcTgBNyCH4w30X2eLaXWWGz/C3KgC2BIo6CYQEgaRpahLY1BwAsntT1oPniuxvc6Q569VVA67XHWKxmwpgrgIe3Plqlz9QEsvqpW2oIR5sRRkCkBZGGQIwD5BDQOA6HzIPjQJiHB46Su9FIOWpreyld2to06j7ix/9+D7AwipaP2+NoPabP0+g9seDk6j9w8pT3PWVAHC9MkRFtTUgJACUE13VLC69EXXLQp0xAED3AWIAIFXOVMjiuwxAAgqgv+lbLv+Kt3+bVAAq+BJyTAGs2e89B8B++fMfKYBzIyiGAph+1BQBg6CW/HuvAhwAtL3/7gKhi4aAxgGwDAOhCiDDolQgaB8gKwA3ZV86tvyuCQXQEoqCwFsFYikApf7KnpgCyGcTsB8Bn6usArpqEhhzDrD/8Kj4/H7evUxLAIDy52UOYqllKrUKiT4JNIaC6Apg+iFkGXj9wKi48SlxACpJVb7I5QEuM0i8XmFMvtiwsMr4ONvI+Fsjgl19kbYC5NgGeYBjmzHPTg+IseeOfw6RyBwgqPe5MNsAwLYlTO0QpjAHyEEM8oBbAaosDzMAQc5PoTAX008Enzmjj/Py4YeaGzj/9Qi0PAOQQgyD2rAeaNeRh4Ag53ZCYRyACj2g1tlUFdQ6nCqf7WEe+AcyHFVtVLXvgwAAAABJRU5ErkJggg==","codigo":"import math\n\nnivel = 0\n\ndef get_pixel(i, x, y):\n    color = obtener_pixel(0, x+(i%16)*8, y+int(i/16)*8)\n    return int(color)\n\ndef crear_nivel(numero):\n    mapa = [\n        [\n            get_pixel(numero+48, x, y) for x in range(16)\n        ] for y in range(16)\n    ]\n    return mapa[::-1]\n\n\nclass Nube:\n    \n    def __init__(self, y, velocidad):\n        self.velocidad = velocidad\n        self.x = azar()\n        self.y = y\n        \n    def actualizar(self):\n        self.x -= self.velocidad\n        \n        if self.x < -16:\n            self.x = 128\n        \n    def dibujar(self):\n        dibujar(16, self.x, self.y)\n        dibujar(17, self.x+8, self.y)\n        \nclass Estrella:\n    \n    def __init__(self):\n        self.x = azar()\n        self.y = azar(0, 50)\n\n    def dibujar(self):\n        pixel(self.x, self.y, azar())\n\nmapa = crear_nivel(0)\nprint_original(mapa)\n\nangulo = math.pi\nposX = 5\nposY = 3\ndirX = -1\ndirY = 0\nplaneX = 0\nplaneY = 0.66\n\npasos = 1\n\ndef get_distance(posX, posY, rayDirX, rayDirY, mapa):\n    mapX = int(posX)\n    mapY = int(posY)\n    \n\n    if rayDirX == 0:\n        deltaDistX = 9999\n    else:\n        deltaDistX = abs(1 / rayDirX)\n    \n    if rayDirY == 0:\n        deltaDistY = 9999\n    else:\n        deltaDistY = abs(1 / rayDirY)\n      \n    if rayDirX < 0:\n        stepX = -1\n        sideDistX = (posX - mapX) * deltaDistX\n    else:\n        stepX = 1;\n        sideDistX = (mapX + 1.0 - posX) * deltaDistX\n        \n    if rayDirY < 0:\n        stepY = -1\n        sideDistY = (posY - mapY) * deltaDistY\n    else:\n        stepY = 1;\n        sideDistY = (mapY + 1.0 - posY) * deltaDistY\n    \n    # mapa\n    # se va a usar sideDistX, sideDistY\n    hit = False\n    \n    for _ in range(10000*2):\n        if sideDistX < sideDistY: # si debe salir horizontalmente\n            sideDistX += deltaDistX;\n            mapX += stepX;\n            side = 0\n        else:\n            sideDistY += deltaDistY;\n            mapY += stepY;\n            side = 1;\n\n        if mapa[mapY][mapX] > 0:\n            hit = True\n            break\n    \n    if side == 0:\n        perpWallDist = (sideDistX - deltaDistX)\n    else:\n        perpWallDist = (sideDistY - deltaDistY)\n        \n\n    if side == 0:\n        wallX = posY + perpWallDist * rayDirY\n    else:\n        wallX = posX + perpWallDist * rayDirX\n    \n    wallX -= math.floor(wallX)\n\n    texX = int(wallX * 8)\n    if side == 0 and rayDirX > 0:\n        texX = 8 - texX - 1\n    if side == 1 and rayDirY < 0:\n        texX = 8 - texX - 1\n      \n    return perpWallDist, mapa[mapY][mapX], side, texX\n\nnubes = [\n    Nube(10, 0.25),\n    Nube(20, 0.20),\n    Nube(30, 0.15),\n    Nube(40, 0.1),\n    Nube(40, 0.1),\n]\n\n\nestrellas = [\n    Estrella() for x in range(50)\n]\n\nwhile True:\n    borrar()\n\n    if nivel == 0:\n        rectangulo(0, 0, 128, 64, 12, True)\n        circulo(10, 10, 25, 10, True)\n        \n        for nube in nubes:\n            nube.actualizar()\n            nube.dibujar()\n    else:\n        rectangulo(0, 0, 128, 64, 1, True)\n        circulo(110, 10, 16, 7, True)\n        \n        for estrella in estrellas:\n            estrella.dibujar()\n    \n    for x in range(0, 128, pasos):\n        cameraX = 2 * x / 128 - 1\n        rayDirX = dirX + planeX * cameraX\n        rayDirY = dirY + planeY * cameraX\n        dist, color, side, texX = get_distance(posX, posY, rayDirX, rayDirY, mapa)\n        \n        lineHeight = int(128 / dist);\n      \n        drawStart = -lineHeight / 2 + 128 / 2;\n        \n        if drawStart < 0:\n            drawStart = 0;\n        \n        drawEnd = lineHeight / 2 + 128 / 2;\n        \n        if drawEnd >= 128:\n            drawEnd = 128 - 1;\n\n        if color == 8:\n            color = azar()\n            linea(x, drawStart, x, drawEnd, color)\n        else:\n            step = 1.0 * 8 / lineHeight\n            texPos = (drawStart - 128 / 2 + lineHeight / 2) * step\n            if side:\n                color += 16\n            indice = color\n            \n            for y in range(int(drawStart), int(drawEnd)):\n                texY = texPos\n                \n                if texY > 7:\n                    texY = 7\n                \n                texPos += step;\n                color2 = get_pixel(32+indice, texX, texY)\n                pixel(x, y, color2)\n                \n    rotSpeed = 0.1\n    \n    if izquierda:\n        oldDirX = dirX;\n        dirX = dirX * coseno(rotSpeed) - dirY * seno(rotSpeed);\n        dirY = oldDirX * seno(rotSpeed) + dirY * coseno(rotSpeed);\n        oldPlaneX = planeX\n        planeX = planeX * coseno(rotSpeed) - planeY * seno(rotSpeed);\n        planeY = oldPlaneX * seno(rotSpeed) + planeY * coseno(rotSpeed);\n    elif derecha:\n        oldDirX = dirX;\n        dirX = dirX * coseno(-rotSpeed) - dirY * seno(-rotSpeed);\n        dirY = oldDirX * seno(-rotSpeed) + dirY * coseno(-rotSpeed);\n        oldPlaneX = planeX;\n        planeX = planeX * coseno(-rotSpeed) - planeY * seno(-rotSpeed);\n        planeY = oldPlaneX * seno(-rotSpeed) + planeY * coseno(-rotSpeed);\n    \n    moveSpeed = 0.1\n    \n    if arriba:\n        colision = mapa[int(posY + dirY * moveSpeed)][int(posX + dirX * moveSpeed)]\n        if colision == 0:\n            posX += dirX * moveSpeed;\n            posY += dirY * moveSpeed;\n        else:\n            if colision == 8:\n                nivel += 1\n                mapa = crear_nivel(nivel%16)\n                posX = 5\n                posY = 3\n                dirX = -1\n                dirY = 0\n                planeX = 0\n                planeY = 0.66\n    if abajo:\n        colision = mapa[int(posY - dirY * moveSpeed)][int(posX - dirX * moveSpeed)]\n        if colision == 0:\n            posX -= dirX * moveSpeed;\n            posY -= dirY * moveSpeed;\n    \n\n    print(f\"nivel: {nivel}\")\n    \n      ","anchoDeTextura":128,"altoDeTextura":40}